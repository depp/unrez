#!/usr/bin/env python3
import itertools
import os
import sys
import unicodedata

# This generates tables for converting to and from the Mac OS Roman character
# set.

CHARACTERS = list(range(128)) + [
    0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1,
    0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8,
    0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3,
    0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC,
    0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF,
    0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8,
    0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211,
    0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x03A9, 0x00E6, 0x00F8,
    0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB,
    0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153,
    0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA,
    0x00FF, 0x0178, 0x2044, 0x20AC, 0x2039, 0x203A, 0xFB01, 0xFB02,
    0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1,
    0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4,
    0xF8FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC,
    0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7,
]

class State:
    __slots__ = ['character', 'table']
    def __init__(self):
        self.character = None
        self.table = None


def main():
    start = State()
    tables = []
    for mchar, uchar in itertools.chain(enumerate(CHARACTERS), [(0xDB, 0xA4)]):
        uchar = chr(uchar)
        ustrings = {uchar, unicodedata.normalize('NFD', uchar)}
        for s in ustrings:
            state = start
            for b in s.encode('UTF-8'):
                table = state.table
                if table is None:
                    table = [None] * 256
                    state.table = len(tables)
                    tables.append(table)
                else:
                    table = tables[table]
                next_state = table[b]
                if next_state is None:
                    next_state = State()
                    table[b] = next_state
                state = next_state
            assert state.character is None
            state.character = mchar
    states = []
    ctables = []
    for table in tables:
        mini = min(i for i, state in enumerate(table) if state is not None)
        maxi = max(i for i, state in enumerate(table) if state is not None)
        ctables.append((len(states) - mini, mini, maxi))
        states.extend(table[mini:maxi+1])

    opath = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                         'macroman.h')

    with open(opath, 'w') as fp:
        write = fp.write
        write('/* This file is automatically generated by macroman.py. */\n')

        write('\nstatic const struct char_state kFromUnicodeState[{}] = {{'
              .format(len(states)))
        delim = '\n'
        for state in states:
            write(delim)
            delim = ',\n'
            char = None
            table = None
            if state is not None:
                char = state.character
                table = state.table
            if char is None:
                char = 0
            if table is None:
                table = 0
            write('{{{},{}}}'.format(char, table))
        write('\n};\n')

        write('\nstatic const struct char_table kFromUnicodeTable[{}] = {{'
              .format(len(ctables)))
        delim = '\n'
        for table in ctables:
            write(delim)
            delim = ',\n'
            write('{{{},{},{}}}'.format(*table))
        write('\n};\n')

        write('\nstatic const unsigned short kToUnicodeTable[256] = {')
        delim = '\n'
        for c in CHARACTERS:
            write(delim)
            write(str(c))
            delim = ',\n'
        write('\n};\n')


if __name__ == '__main__':
    main()
