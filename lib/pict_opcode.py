#!/usr/bin/env python3
import sys

# There is a little bit of guesswork in this. The Imaging With QuickDraw book
# lists $02FF as the "Version" opcode, but it's really the data for the $0011
# payload. It also gives it a size of 2. This contradicts the decompiled picture
# in listing A-5 on p. A-23, which gives it no data at all, and also contradicts
# the note on p. A-5, which says that the amount of data should be 4
# bytes. Saying that it isn't an opcode at all seems like the least
# contradictory option.

# Blank lines correspond to page breaks in Imaging With QuickDraw.
OPCODES = '''\
0000 NOP 0
0001 Clip Region
0002 BkPat 8
0003 TxFont 2
0004 TxFace 1
0005 TxMode 2

0006 SpExtra 4
0007 PnSize 4
0008 PnMode 2
0009 PnPat 8
000A FillPat 8
000B OvSize 4
000C Origin 4
000D TxSize 2
000E FgColor 4
000F BkColor 4
0010 TxRatio 8
0011 VersionOp Version
0012 BkPixPat Pattern
0013 PnPixPat Pattern
0014 FillPixPat Pattern
0015 PnLocHFrac 2
0016 ChExtra 2
0017-0019 Reserved NotDetermined
001A RGBFgCol 6
001B RGBBkCol 6

001C HiliteMode 0
001D HiliteColor 6
001E DefHilite 0
001F OpColor 6
0020 Line 8
0021 LineFrom 4
0022 ShortLine 6
0023 ShortLineFrom 2
0024-0027 Reserved Data16
0028 LongText Text
0029 DHText Text
002A DVText Text
002B DHDVText Text
002C fontName Text
002D lineJustify 10
002E glyphState 8

002F Reserved Data16
0030 frameRect 8
0031 paintRect 8
0032 eraseRect 8
0033 invertRect 8
0034 fillRect 8
0035-0037 Reserved 8
0038 frameSameRect 0
0039 paintSameRect 0
003A eraseSameRect 0
003B invertSameRect 0
003C fillSameRect 0
003D-003F Reserved 0
0040 frameRRect 8
0041 paintRRect 8
0042 eraseRRect 8
0043 invertRRect 8
0044 fillRRect 8
0045-0047 Reserved 8
0048 frameSameRRect 0
0049 paintSameRRect 0
004A eraseSameRRect 0
004B invertSameRRect 0
004C fillSameRRect 0

004D-004F Reserved 0
0050 frameOval 8
0051 paintOval 8
0052 eraseOval 8
0053 invertOval 8
0054 fillOval 8
0055-0057 Reserved 8
0058 frameSameOval 0
0059 paintSameOval 0
005A eraseSameOval 0
005B invertSameOval 0
005C fillSameOval 0
005D-005F Reserved 0
0060 frameArc 12
0061 paintArc 12
0062 eraseArc 12
0063 invertArc 12
0064 fillArc 12
0065-0067 Reserved 12

0068 frameSameArc 4
0069 paintSameArc 4
006A eraseSameArc 4
006B invertSameArc 4
006C fillSameArc 4
006D-006F Reserved 4
0070 framePoly Polygon
0071 paintPoly Polygon
0072 erasePoly Polygon
0073 invertPoly Polygon
0074 fillPoly Polygon
0075-0077 Reserved Polygon
0078 frameSamePoly 0
0079 paintSamePoly 0
007A eraseSamePoly 0
007B invertSamePoly 0
007C fillSamePoly 0
007D-007F Reserved 0
0080 frameRgn Region
0081 paintRgn Region
0082 eraseRgn Region
0083 invertRgn Region

0084 fillRgn Region
0085-0087 Reserved Region
0088 frameSameRgn 0
0089 paintSameRgn 0
008A eraseSameRgn 0
008B invertSameRgn 0
008C fillSameRgn 0
008D-008F Reserved 0
0090 BitsRect PixelData
0091 BitsRgn PixelData
0092-0097 Reserved Data16
0098 PackBitsRect PixelData
0099 PackBitsRgn PixelData
009A DirectBitsRect PixelData

009B DirectBitsRgn PixelData
009C-009F Reserved Data16
00A0 ShortComment 2
00A1 LongComment LongComment
00A2-00AF Reserved Data16
00B0-00CF Reserved 0
00D0-00FE Reserved Data32
00FF OpEndPic End
0C00 HeaderOp 0
8200 CompressedQuickTime 0
8201 UncompressedQuickTime 0
'''

def main():
    opset = set()
    names = []
    name_len = 0
    tbl_data = [None] * 256
    tbl_name = [None] * 256
    tbl_ext = []
    enum = []
    min_start = 0
    for line in OPCODES.splitlines():
        fields = line.split()
        if not fields:
            continue
        oprange, name, data = fields
        oprange = oprange.split('-')
        if len(oprange) == 1:
            start = int(oprange[0], 16)
            end = start
            assert start >= min_start
            opset.add(start)
        elif len(oprange) == 2:
            start = int(oprange[0], 16)
            end = int(oprange[1], 16)
            assert start >= min_start
            assert start < end
            nopset = set(range(start, end + 1))
            opset.update(nopset)
        else:
            assert False
        min_start = end + 1

        if name.lower() == 'reserved':
            name_idx = 0
        else:
            assert start == end
            name_idx = name_len + 1
            names.append(name)
            name_len += len(name) + 1
            enum.append((name, start))
        try:
            data = int(data)
        except ValueError:
            data = '-kType{}-1'.format(data)
        else:
            data = str(data)

        if start <= 255:
            assert end <= 255
            for i in range(start, end + 1):
                tbl_data[i] = data
                tbl_name[i] = name_idx
        else:
            assert start == end
            tbl_ext.append((start, name_idx))

    assert opset.issuperset(range(256))

    write = sys.stdout.write
    write('/* This file is automatically generated by pict_opcode.py. */\n')

    write('\nenum {')
    nl = '\n'
    next_value = 0
    for name, value in enum:
        write(nl)
        write('kOp_')
        write(name)
        if value != next_value:
            write(' = 0x{:04x}'.format(value))
        next_value = value + 1
        nl = ',\n'
    write('\n};\n')

    write('\nstatic const char kOpcodeNames[] =')
    nl = '\n'
    for name in names:
        write(nl)
        write('"')
        write(name)
        nl = '\\0"\n'
    write('";\n')

    write('\nstatic const unsigned short kOpcodeNameTable[256] = {\n')
    comma = ''
    start = 0
    for i in range(16):
        end = (i + 1) * 16
        for name_idx in tbl_name[start:end]:
            write(comma)
            write(str(name_idx))
            comma = ','
        comma = ',\n'
        start = end
    write('\n};\n')

    write('\nstatic const short kOpcodeDataTable[256] = {\n')
    comma = ''
    start = 0
    for i in range(64):
        end = (i + 1) * 4
        for data in tbl_data[start:end]:
            write(comma)
            write(data)
            comma = ','
        comma = ',\n'
        start = end
    write('\n};\n')

    write('\nstatic const struct extended_opcode kExtendedOpcodes[] = {\n')
    comma = ''
    for row in tbl_ext:
        write(comma)
        write('{{0x{:04x}, {}}}'.format(*row))
        comma = ',\n'
    write('\n};\n')

if __name__ == '__main__':
    main()
